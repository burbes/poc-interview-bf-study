pipeline {
    agent any
    
    environment {
        HOME = "${env.WORKSPACE}"
        MAVEN_OPTS = '-Xmx512m'
        ARTIFACTORY_CREDENTIALS = credentials('artifactory-credentials')
        SONAR_CREDENTIALS = credentials('sonar-credentials')
        DOCKER_CREDENTIALS = credentials('docker-credentials')
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                sh 'git --version'
                sh 'mvn --version'
                echo "Building branch: ${env.BRANCH_NAME}"
            }
        }
        stage('Debug Info') {
            steps {
                echo "Pipeline started"
                echo "BRANCH_NAME: ${env.BRANCH_NAME}"
                echo "WORKSPACE: ${env.WORKSPACE}"
                sh 'printenv'
            }
        }
        
        stage('Clean & Compile') {
            steps {
                sh 'mvn clean compile'
            }
        }
        
        stage('Test') {
            steps {
                sh 'mvn test'
            }
            post {
                always {
                    junit '**/target/surefire-reports/*.xml'
                }
            }
        }
        
        stage('Code Quality Analysis') {
            steps {
                withSonarQubeEnv('SonarQube') {
                    sh '''
                        mvn sonar:sonar \
                        -Dsonar.projectKey=task-management-system \
                        -Dsonar.host.url=${SONAR_HOST} \
                        -Dsonar.login=${SONAR_CREDENTIALS}
                    '''
                }
            }
        }
        
        stage('Package') {
            steps {
                sh 'mvn package -DskipTests'
                archiveArtifacts artifacts: 'target/*.jar', fingerprint: true
            }
        }
        
        stage('Publish to Artifactory') {
            //when {
            //     expression { env.BRANCH_NAME == 'main' || env.BRANCH_NAME == 'develop' }
            //  }
            steps {
                script {
                    def server = Artifactory.server 'artifactory-server'
                    def buildInfo = Artifactory.newBuildInfo()
                    buildInfo.env.capture = true
                    
                    def rtMaven = Artifactory.newMavenBuild()
                    rtMaven.tool = 'Maven'
                    rtMaven.deployer releaseRepo: 'libs-release-local', snapshotRepo: 'libs-snapshot-local', server: server
                    rtMaven.deployer.deployArtifacts = true
                    
                    rtMaven.run pom: 'pom.xml', goals: 'install', buildInfo: buildInfo
                    server.publishBuildInfo buildInfo
                }
            }
        }
        
        stage('Build Docker Image') {
            // when {
            //     expression { env.BRANCH_NAME == 'main' || env.BRANCH_NAME == 'develop' }
            // }
            steps {
                script {
                    def imageTag = "${env.BRANCH_NAME}-${env.BUILD_NUMBER}-${env.GIT_COMMIT.substring(0,7)}"
                    env.IMAGE_TAG = imageTag
                    sh "docker build -t task-management-system:${imageTag} -f docker/Dockerfile ."
                }
            }
        }
        
        stage('Push Docker Image') {
            // when {
            //     expression { env.BRANCH_NAME == 'main' || env.BRANCH_NAME == 'develop' }
            // }
            steps {
                script {
                    docker.withRegistry('https://registry.example.com', 'docker-credentials') {
                        sh "docker tag task-management-system:${env.IMAGE_TAG} registry.example.com/task-management-system:${env.IMAGE_TAG}"
                        sh "docker push registry.example.com/task-management-system:${env.IMAGE_TAG}"
                    }
                }
            }
        }
        
        stage('Deploy to Dev') {
            // when {
            //     expression { env.BRANCH_NAME == 'develop' }
            // }
            steps {
                echo 'Deploying to Development environment...'
                // Use Ansible for deployment
                ansiblePlaybook(
                    playbook: 'ansible/playbooks/deploy-dev.yml',
                    inventory: 'ansible/inventory/dev',
                    extraVars: [
                        app_version: "${env.BUILD_NUMBER}",
                        environment: 'dev'
                    ]
                )
            }
        }
        
        stage('Deploy to Staging') {
            // when {
            //     expression { env.BRANCH_NAME == 'main' }
            // }
            steps {
                echo 'Deploying to Staging environment...'
                // Manual approval before deploying to staging
                input message: 'Deploy to Staging environment?', ok: 'Deploy'
                // Use Ansible for deployment
                ansiblePlaybook(
                    playbook: 'ansible/playbooks/deploy-staging.yml',
                    inventory: 'ansible/inventory/staging',
                    extraVars: [
                        app_version: "${env.BUILD_NUMBER}",
                        environment: 'staging'
                    ]
                )
            }
        }
        
        stage('Deploy to Production') {
            // when {
            //     expression { env.BRANCH_NAME == 'main' }
            // }
            steps {
                echo 'Deploying to Production environment...'
                // Manual approval before deploying to production
                input message: 'Deploy to Production environment?', ok: 'Deploy'
                // Use Ansible for deployment
                ansiblePlaybook(
                    playbook: 'ansible/playbooks/deploy-prod.yml',
                    inventory: 'ansible/inventory/prod',
                    extraVars: [
                        app_version: "${env.BUILD_NUMBER}",
                        environment: 'prod'
                    ]
                )
            }
        }
        
        stage('Rollback') {
            // when {
            //     beforeAgent true
            //     expression { params.ROLLBACK_TO_TAG != null && params.ROLLBACK_TO_TAG != '' }
            // }
            steps {
                echo "Rolling back to Docker image tag: ${params.ROLLBACK_TO_TAG}"
                // Use Ansible to redeploy previous image
                ansiblePlaybook(
                    playbook: 'ansible/playbooks/deploy-${env.ENVIRONMENT}.yml',
                    inventory: "ansible/inventory/${env.ENVIRONMENT}",
                    extraVars: [
                        app_version: "${params.ROLLBACK_TO_TAG}",
                        environment: env.ENVIRONMENT
                    ]
                )
            }
        }
    }
    
    post {
        always {
            echo 'Pipeline execution completed'
            // Clean workspace
            cleanWs()
        }
        success {
            echo 'Pipeline executed successfully'
            // Send success notification
            // mail to: 'team@example.com',
            //      subject: "Pipeline succeeded: ${currentBuild.fullDisplayName}",
            //      body: "The pipeline ${env.JOB_NAME} completed successfully. Build URL: ${env.BUILD_URL}"
        }
        failure {
            echo 'Pipeline execution failed'
            // Send failure notification
            // mail to: 'team@example.com',
            //      subject: "Pipeline failed: ${currentBuild.fullDisplayName}",
            //      body: "The pipeline ${env.JOB_NAME} failed. Build URL: ${env.BUILD_URL}"
        }
    }
}

