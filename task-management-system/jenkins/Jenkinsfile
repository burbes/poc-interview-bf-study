pipeline {
    agent any
    
    environment {
        HOME = "${env.WORKSPACE}"
        MAVEN_OPTS = '-Xmx512m'
        // ARTIFACTORY_CREDENTIALS = credentials('artifactory-credentials')
        // SONAR_CREDENTIALS = credentials('sonar-credentials')
        DOCKER_CREDENTIALS = credentials('docker-credentials')
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_USERNAME = 'burbes'
        DOCKER_REPO = 'task-management-system'
        DOCKER_CONFIG = "${env.WORKSPACE}/.docker"
        // Disable macOS keychain for Docker
        DOCKER_CLI_EXPERIMENTAL = "enabled"
        // Explicit Docker path configuration
        DOCKER_PATH = "/opt/homebrew/bin:/usr/local/bin"
        // Disable credential helpers to avoid keychain issues
        DOCKER_CONFIG_NO_HELPERS = '{"auths":{}, "credsStore": "", "credHelpers": {}}'
        // Docker socket location - for macOS
        DOCKER_HOST = "unix:///var/run/docker.sock"
        // Prevent Docker from using keychain on macOS
        DOCKER_CREDENTIAL_HELPER = "none"
        JAVA_HOME = "/opt/homebrew/opt/openjdk@21"
        PATH = "/opt/homebrew/opt/openjdk@21/bin:${DOCKER_PATH}:${env.PATH}"
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                sh 'git --version'
                sh 'mvn --version'
                echo "Building branch: ${env.BRANCH_NAME}"
            }
        }
        stage('Debug Info') {
            steps {
                echo "Pipeline started"
                echo "BRANCH_NAME: ${env.BRANCH_NAME}"
                echo "WORKSPACE: ${env.WORKSPACE}"
                sh 'printenv'
            }
        }
        
        stage('Clean & Compile') {
            steps {
                sh 'cd task-management-system && mvn clean compile'
            }
        }
        
        stage('Test') {
            steps {
                sh 'cd task-management-system && mvn test'
            }
            post {
                always {
                    junit '**/target/surefire-reports/*.xml'
                }
            }
        }
        
        stage('Code Quality Analysis') {
            steps {
                // withSonarQubeEnv('SonarQube') {
                //     sh '''
                //         mvn sonar:sonar \
                //         -Dsonar.projectKey=task-management-system \
                //         -Dsonar.host.url=${SONAR_HOST} \
                //         -Dsonar.login=${SONAR_CREDENTIALS}
                //     '''
                // }
                echo 'SonarQube analysis skipped.'
            }
        }
        
        stage('Package') {
            steps {
                sh 'cd task-management-system && mvn package -DskipTests'
                archiveArtifacts artifacts: 'task-management-system/target/*.jar', fingerprint: true
            }
        }
        
        // stage('Publish to Artifactory') {
        //     //when {
        //     //     expression { env.BRANCH_NAME == 'main' || env.BRANCH_NAME == 'develop' }
        //     //  }
        //     steps {
        //         script {
        //             def server = Artifactory.server 'artifactory-server'
        //             def buildInfo = Artifactory.newBuildInfo()
        //             buildInfo.env.capture = true
        //             def rtMaven = Artifactory.newMavenBuild()
        //             rtMaven.tool = 'Maven'
        //             rtMaven.deployer releaseRepo: 'libs-release-local', snapshotRepo: 'libs-snapshot-local', server: server
        //             rtMaven.deployer.deployArtifacts = true
        //             rtMaven.run pom: 'pom.xml', goals: 'install', buildInfo: buildInfo
        //             server.publishBuildInfo buildInfo
        //         }
        //     }
        // }
        
        stage('Verify Docker') {
            steps {
                sh 'which docker'
                sh 'docker --version'
                sh 'echo $PATH'
                // Verify Docker socket access
                sh 'docker info || true'
                // Test Docker commands
                sh '''
                    echo "Testing Docker commands..."
                    docker ps -a || echo "Warning: Cannot list containers"
                    echo "Docker environment:"
                    env | grep DOCKER || true
                    echo "Checking Docker socket permissions:"
                    ls -la /var/run/docker.sock || true
                '''
            }
        }
        
        stage('Build Docker Image') {
            // when {
            //     expression { env.BRANCH_NAME == 'main' || env.BRANCH_NAME == 'develop' }
            // }
            steps {
                script {
                    // Ensure branch name is not null - use 'dev' as default
                    def branchName = env.BRANCH_NAME != null ? env.BRANCH_NAME : 'dev'
                    // Make sure GIT_COMMIT is available, use 'latest' if not
                    def gitCommit = env.GIT_COMMIT != null ? env.GIT_COMMIT.substring(0,7) : 'latest'
                    def imageTag = "${branchName}-${env.BUILD_NUMBER}-${gitCommit}"
                    
                    echo "Building Docker image with tag: ${imageTag}"
                    
                    env.IMAGE_TAG = imageTag
                    env.FULL_IMAGE_NAME = "${env.DOCKER_USERNAME}/${env.DOCKER_REPO}"
                    
                    // Add error handling for Docker build
                    try {
                        sh "docker build -t ${env.FULL_IMAGE_NAME}:${imageTag} -f task-management-system/docker/Dockerfile task-management-system"
                        echo "Docker image built successfully: ${env.FULL_IMAGE_NAME}:${imageTag}"
                    } catch (Exception e) {
                        echo "Error building Docker image: ${e.message}"
                        error "Docker build failed"
                    }
                }
            }
        }
        
        stage('Push Docker Image') {
            // when {
            //     expression { env.BRANCH_NAME == 'main' || env.BRANCH_NAME == 'develop' }
            // }
            steps {
                script {
                    // Create a directory for Docker configuration
                    def dockerConfig = "${env.WORKSPACE}/.docker"
                    
                    // Create a Docker config without keychain integration
                    sh "mkdir -p ${dockerConfig}"
                    sh "echo '${DOCKER_CONFIG_NO_HELPERS}' > ${dockerConfig}/config.json"
                    sh "cat ${dockerConfig}/config.json"
                    
                    // Validate image tag before proceeding
                    if (env.IMAGE_TAG == null || env.IMAGE_TAG.trim() == '') {
                        error "IMAGE_TAG is not defined or empty. Cannot push Docker image."
                    }
                    
                    echo "Preparing to push Docker image: ${env.FULL_IMAGE_NAME}:${env.IMAGE_TAG}"
                    
                    withCredentials([usernamePassword(credentialsId: 'docker-credentials', passwordVariable: 'DOCKER_PASSWORD', usernameVariable: 'DOCKER_USERNAME')]) {
                        try {
                            // Use docker login with --config option to specify isolated config
                            sh """
                                echo "Logging into Docker registry with isolated config..."
                                docker --config=${dockerConfig} login -u ${DOCKER_USERNAME} -p ${DOCKER_PASSWORD} ${DOCKER_REGISTRY}
                                echo "Docker login successful!"
                            """
                            
                            // Push the Docker image using the isolated config
                            sh """
                                echo "Pushing Docker image ${env.FULL_IMAGE_NAME}:${env.IMAGE_TAG}..."
                                docker --config=${dockerConfig} push ${env.FULL_IMAGE_NAME}:${env.IMAGE_TAG}
                            """
                            echo "Successfully pushed ${env.FULL_IMAGE_NAME}:${env.IMAGE_TAG}"
                            
                            // If it's main branch, also tag as latest
                            def branchName = env.BRANCH_NAME != null ? env.BRANCH_NAME : 'dev'
                            if (branchName == 'main') {
                                sh "docker --config ${dockerConfig} tag ${env.FULL_IMAGE_NAME}:${env.IMAGE_TAG} ${env.FULL_IMAGE_NAME}:latest"
                                sh "docker --config ${dockerConfig} push ${env.FULL_IMAGE_NAME}:latest"
                                echo "Successfully pushed ${env.FULL_IMAGE_NAME}:latest"
                            }
                        } catch (Exception e) {
                            echo "Error during Docker push: ${e.message}"
                            sh "docker logout || true"
                            error "Failed to push Docker image: ${e.message}"
                        } finally {
                            // Proper Docker logout to clean up credentials
                            sh "docker logout || true"
                            echo "Docker credentials cleaned up"
                        }
                    }
                }
            }
        }
        
        stage('Deploy to Dev') {
            // when {
            //     expression { env.BRANCH_NAME == 'develop' }
            // }
            steps {
                echo 'Deploying to Development environment...'
                // Debug: Show PATH and Ansible info
                sh 'echo $PATH'
                sh 'which ansible-playbook || true'
                sh 'ansible-playbook --version || true'
                sh 'ansible-galaxy collection list || true'
                // Use Ansible for deployment
                ansiblePlaybook(
                    playbook: 'task-management-system/ansible/playbooks/deploy-dev.yml',
                    inventory: 'task-management-system/ansible/inventory/dev',
                    extraVars: [
                        app_version: "${env.BUILD_NUMBER}",
                        environment: 'dev',
                        docker_image: "${env.FULL_IMAGE_NAME}:${env.IMAGE_TAG}"
                    ]
                )
            }
        }
        
        stage('Deploy to Staging') {
            // when {
            //     expression { env.BRANCH_NAME == 'main' }
            // }
            steps {
                echo 'Deploying to Staging environment...'
                // Manual approval before deploying to staging
                input message: 'Deploy to Staging environment?', ok: 'Deploy'
                // Use Ansible for deployment
                ansiblePlaybook(
                    playbook: 'task-management-system/ansible/playbooks/deploy-staging.yml',
                    inventory: 'task-management-system/ansible/inventory/staging',
                    extraVars: [
                        app_version: "${env.BUILD_NUMBER}",
                        environment: 'staging',
                        docker_image: "${env.FULL_IMAGE_NAME}:${env.IMAGE_TAG}"
                    ]
                )
            }
        }
        
        stage('Deploy to Production') {
            // when {
            //     expression { env.BRANCH_NAME == 'main' }
            // }
            steps {
                echo 'Deploying to Production environment...'
                // Manual approval before deploying to production
                input message: 'Deploy to Production environment?', ok: 'Deploy'
                // Use Ansible for deployment
                ansiblePlaybook(
                    playbook: 'task-management-system/ansible/playbooks/deploy-prod.yml',
                    inventory: 'task-management-system/ansible/inventory/prod',
                    extraVars: [
                        app_version: "${env.BUILD_NUMBER}",
                        environment: 'prod',
                        docker_image: "${env.FULL_IMAGE_NAME}:${env.IMAGE_TAG}"
                    ]
                )
            }
        }
        
        stage('Rollback') {
            // when {
            //     beforeAgent true
            //     expression { params.ROLLBACK_TO_TAG != null && params.ROLLBACK_TO_TAG != '' }
            // }
            steps {
                echo "Rolling back to Docker image tag: ${params.ROLLBACK_TO_TAG}"
                // Use Ansible to redeploy previous image
                ansiblePlaybook(
                    playbook: 'task-management-system/ansible/playbooks/deploy-${env.ENVIRONMENT}.yml',
                    inventory: "task-management-system/ansible/inventory/${env.ENVIRONMENT}",
                    extraVars: [
                        app_version: "${params.ROLLBACK_TO_TAG}",
                        environment: env.ENVIRONMENT,
                        docker_image: "${env.DOCKER_USERNAME}/${env.DOCKER_REPO}:${params.ROLLBACK_TO_TAG}"
                    ]
                )
            }
        }
    }
    
    post {
        always {
            echo 'Pipeline execution completed'
            // Clean up any Docker config files
            sh 'rm -rf ${WORKSPACE}/.docker || true'
            // Clean workspace
            cleanWs()
        }
        success {
            echo 'Pipeline executed successfully'
            // Send success notification
            // mail to: 'team@example.com',
            //      subject: "Pipeline succeeded: ${currentBuild.fullDisplayName}",
            //      body: "The pipeline ${env.JOB_NAME} completed successfully. Build URL: ${env.BUILD_URL}"
        }
        failure {
            echo 'Pipeline execution failed'
            // Capture details about what stage failed
            script {
                def failedStage = currentBuild.result
                echo "Pipeline failed at stage: ${failedStage}"
            }
            // Send failure notification
            // mail to: 'team@example.com',
            //      subject: "Pipeline failed: ${currentBuild.fullDisplayName}",
            //      body: "The pipeline ${env.JOB_NAME} failed. Build URL: ${env.BUILD_URL}"
        }
    }
}

